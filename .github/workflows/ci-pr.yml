name: CI (Pull Request)

on: [pull_request]

jobs:
  # This job checks which services have changed
  changed-files:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      app: ${{ steps.filter.outputs.app }}
      auth: ${{ steps.filter.outputs.auth }}
      website: ${{ steps.filter.outputs.website }}
      integration: ${{ steps.filter.outputs.integration }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            api:
              - 'api/**'
            app:
              - 'app/**'
            auth:
              - 'auth/**'
            website:
              - 'website/**'
            # The integration tests should also run if the test files themselves change
            integration:
              - 'api/**'
              - 'app/**'
              - 'auth/**'
              - 'tests/integration/**'

  unit-tests:
    runs-on: ubuntu-latest
    needs: changed-files
    strategy:
      matrix:
        # We define all services here
        service: [api, app, auth, website]
        # Create conditional inclusions
        include:
          - service: api
            path: 'api'
            run_if: ${{ needs.changed-files.outputs.api == 'true' }}
          - service: app
            path: 'app'
            run_if: ${{ needs.changed-files.outputs.app == 'true' }}
          - service: auth
            path: 'auth'
            run_if: ${{ needs.changed-files.outputs.auth == 'true' }}
          - service: website
            path: 'website'
            run_if: ${{ needs.changed-files.outputs.website == 'true' }}
    
    # Only run the step if the 'run_if' condition is met
    if: ${{ matrix.run_if }}
    
    steps:
      - uses: actions/checkout@v4
      - name: Run Unit Tests for ${{ matrix.service }}
        run: |
          cd ${{ matrix.path }}
          # This command would be specific to each service
          # e.g., npm test, or pytest
          echo "Running unit tests for ${{ matrix.service }}..."
          # Example: npm install && npm test

  integration-test:
    runs-on: ubuntu-latest
    needs: [changed-files, unit-tests]
    
    # This is the key: Only run this job if api, app, auth, or the tests themselves changed
    if: ${{ needs.changed-files.outputs.integration == 'true' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Start Services
        run: |
          # Use the existing devcontainer docker-compose to start all services
          docker-compose -f.devcontainer/docker-compose.yml up -d

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services..."
          # This is a simple wait; a more robust solution would poll the /health endpoints
          sleep 30 
      
      - name: Run Integration Tests
        run: |
          # We execute the tests *inside* one of the running containers
          # that has the necessary tools (e.g., Python/pytest)
          # We use the 'api' service container, which uses the 'dev-python' image
          docker-compose -f.devcontainer/docker-compose.yml exec -T api \
            bash -c "pip install -r /workspace/tests/integration/requirements.txt && pytest /workspace/tests/integration"

      - name: Stop Services
        if: always() # Always run this step to clean up
        run: |
          docker-compose -f.devcontainer/docker-compose.yml down