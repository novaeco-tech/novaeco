name: NovaEco Core CI

on:
  pull_request:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  # Job 1: Detect changes
  changed-files:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      app: ${{ steps.filter.outputs.app }}
      auth: ${{ steps.filter.outputs.auth }}
      website: ${{ steps.filter.outputs.website }}
      integration: ${{ steps.filter.outputs.integration }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            api: ['api/**']
            app: ['app/**']
            auth: ['auth/**']
            website: ['website/**']
            # Integration tests should run if ANY backend service or the tests themselves change
            integration:
              - 'api/**'
              - 'auth/**'
              - 'app/**'
              - 'tests/integration/**'
              - '.devcontainer/docker-compose.yml'

  # Job 2: Unit Test API (Python)
  test-api:
    needs: changed-files
    if: ${{ needs.changed-files.outputs.api == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/novaeco-tech/dev-python:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - name: Install Dependencies
        # Only install external libs for unit tests to keep it fast
        run: pip install -r api/requirements.txt
      - name: Run Unit Tests
        # Run from service root to ensure src/ imports work
        run: cd api && pytest tests/unit

  # Job 3: Unit Test App (Python)
  test-app:
    needs: changed-files
    if: ${{ needs.changed-files.outputs.app == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/novaeco-tech/dev-python:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - name: Install Dependencies
        run: pip install -r app/requirements.txt
      - name: Run Unit Tests
        # Run from service root
        run: cd app && pytest tests/unit

  # Job 4: Unit Test Auth (Python)
  test-auth:
    needs: changed-files
    if: ${{ needs.changed-files.outputs.auth == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/novaeco-tech/dev-python:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - name: Install Dependencies
        run: pip install -r auth/requirements.txt
      - name: Run Unit Tests
        # Run from service root
        run: cd auth && pytest tests/unit

  # Job 5: Unit Test Website (Node.js)
  test-website:
    needs: changed-files
    if: ${{ needs.changed-files.outputs.website == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/novaeco-tech/dev-node:latest
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - name: Install Dependencies
        run: cd website && npm install
      - name: Run Tests
        # Run from website root where package.json lives
        run: cd website && npm test -- tests/unit

  # Job 6: Integration Tests (Docker Compose)
  # This spins up the full environment to test communication between containers
  test-integration:
    needs: changed-files
    if: ${{ needs.changed-files.outputs.integration == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Compose
        # We need the devtools CLI to generate the client if we were building locally,
        # but for CI we usually rely on requirements.txt
        run: docker compose -f .devcontainer/docker-compose.yml up -d --build

      - name: Wait for Healthchecks
        run: |
          # Simple wait loop to ensure services are up
          echo "Waiting for services..."
          sleep 10
          docker ps

      - name: Run Integration Tests
        # We run this OUTSIDE the container (on the runner) or utilize a specific service
        # Here we use the 'app' container to run the tests since it has python access to the network
        run: |
          docker compose -f .devcontainer/docker-compose.yml exec -T app \
            pytest /workspace/tests/integration